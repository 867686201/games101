# 14. Ray Tracing（accelerate）

- **光线**与**场景**求交点
  - 对每一个像素，需要对**所有三角形面**与光线的求交
  - 找到最近的交点（t最小）
- 问题
  - 复杂度：像素数量 x 三角形面数量 x 弹射次数

## 1. Bounding Volumes （包围盒）

### 1. 概念

利用简单的盒子将复杂的物体包围起来

- 物体完全被包围盒包括
- 如果没有碰到包围盒，那更不会碰到物体
- 先进行包围盒测试，然后再对里面的物体测试

### 2. Box

- 理解：一个盒子是三对平行面构成的交体
- 通常使用**轴对齐包围盒** Axis-Aligned Bounding Box（AABB）
  - 任意一对平面与坐标轴垂直

<img src="L14.ray tracing(accelerate).assets/image-20221202150159365.png" alt="image-20221202150159365" style="zoom:80%;" /> 

- 其他包围盒（见ppt）

<img src="L14.ray tracing(accelerate).assets/image-20221202151713385.png" alt="image-20221202151713385" style="zoom:67%;" /> 

- Sphere
  - 光线求交快，但包围盒不够紧密
- AABB
  - 光线求交快，但包围盒不够紧密
  - 不能旋转物体
- OBB 方向包围盒
  - 任意方向
  - 物体旋转时不需要重新计算
  - 构造时开销更大
  - 使用PCA构造

### 3. Ray Intersection with AABB

#### 思想

- 只有当光线**进入**了**所有**的**平面对**才算是真正**进入了盒子**中
- 只要当光线**离开**了**任意平面对**就算是真正**离开了盒子** 

由于光线是射线（$t\ge0$），这里考虑 $t\in R$，即光线所在直线

- 进入某个平面对 —— $t_{min}$ 
- 进入所有平面对 —— $t_{enter} = max\{t_{min}\}$
- 离开某个平面对 —— $t_{max}$ 
- 离开所有平面对 —— $t_{exit} = min\{t_{max}\}$ 
- 如果 $t_{enter} < t_{exit}$，说明光线**所在直线**经过了物体
  - $t_{enter} < t_{exit} < 0$，物体在光线背后
  - $t_{enter}<0 \le t_{exit}$，光源在物体内部，有交点

因此光线和AABB有交点的条件为 $t_{enter} < t_{exit}\ \&\&\ t_{exit} \ge 0 $ 

<img src="L14.ray tracing(accelerate).assets/image-20221202151826524.png" alt="image-20221202151826524" style="zoom:67%;" /> 

#### 计算

使用AABB计算更为简单 

<img src="L14.ray tracing(accelerate).assets/image-20221202153812412.png" alt="image-20221202153812412" style="zoom:67%;" /> 

## 2. Partition

在介绍完AABB之后，相信大家已经了解了其原理及实现方法，那接下来我们就要介绍一些利用AABB的加速方法。当然有些读者可能会有些疑惑，明明已经可以通过事先对每个物体求一个包围盒，在与三角形面求交之前先对包围盒求交，这样不是已经可以达到不错加速效果了吗？作者认为可以考虑这样两个极端情况：

**1 整个场景只有一个极其复杂的单一人物模型，那么只对这一个物体做包围盒的话，相当于对效率没有任何提升**

**2 整个场景充斥着大量的细小模型，如草，花之类的，每个模型可能只有很少的面，如果此时对每个物体求包围盒，得到的包围盒数量会相当之多，对于光线追踪效率来说效率提升有限**

基于以上两点考虑，AABB并不应只局限于以物体模型为单位，可以更加精细的考虑到以三角面为单位。另外对于场景的许许多多包围盒来说应该要有一种数据结构将其统领起来。 **因此如何更好的划分场景形成不同的AABB，使得划分之后的AABB能够更好的加速光线追踪，这就是接下来要考虑的问题关键！** (以下的划分形成的AABB更是一种general的概念，可能不会严格包围物体，读者不必纠结) 

### 1. Uniform Spatial Partition（Grids）均匀空间划分

| ![image-20221202165156424](L14.ray tracing(accelerate).assets/image-20221202165156424.png) | ![image-20221202165206515](L14.ray tracing(accelerate).assets/image-20221202165206515.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

- 找到包围盒
- 创建**均匀网格** 
  - 经验规律：网格数量为27倍物体数量
- 将每个**物体**（表面）存储在**对应网格** 
- 根据光线方向判断所有**相交的网格** 
  - 光线只要知道方向，如向右上，则下一个网格要么是右边一个网格，要么是上面一个
  - [bresenham 算法](https://zhuanlan.zhihu.com/p/507645801) 
- 如果网格中有物体，进一步与**网格中的物体/三角面**求交

- **优点**
  - 比较适合用在**动态**的空间中
  - 最适合的场景就是空间中**均匀布满**了三角形面
- **缺点**
  - 场景**空旷**，物体较小且**分离得比较开**时，那么均匀分割的**效果**就比较**差** 

### 2.  Spatial Partition

<img src="L14.ray tracing(accelerate).assets/image-20221207092510307.png" alt="image-20221207092510307" style="zoom:67%;" /> 

如果某块没有跟任何物体相交，切割的足够小，或空间中三角形数量很少时，停止切割

[参考资料](https://zhuanlan.zhihu.com/p/400749079) 

#### 1. Oct-Tree

- 是一种**固定**的划分方法
- 在空间数据分布**均匀**时，效率较高
- 如果分布**不均匀** 
  - 构成**不平衡**的树
  - **浪费**大量**空间**（空节点）
- 并且随着**维度**的上升**划分空间的数量**呈指数级增长

#### 2. KD-Tree

##### 1. 创建

<img src="L14.ray tracing(accelerate).assets/image-20221207094055434.png" alt="image-20221207094055434" style="zoom:67%;" /> 



- **叶子**节点
  - 存储**物体**list
- **内部**节点
  - 不存储物体
  - **分割轴**：是x轴，y轴或者z轴
  - **分割位置**：如三维空间中横着一刀切开，只需要给出z轴坐标
  - **两个子节点**指针

- 选择哪个轴？
  - 依次选择每个轴
  - 选择最长的轴
  - 不是必须跟兄弟节点使用相同的轴
- 如何选择划分位置
  - 坐标轴的中点
  - 物体数据的中点
  - 能够使两边物体数量相等的点

- 伪算法

<img src="L14.ray tracing(accelerate).assets/image-20221207102053607.png" alt="image-20221207102053607" style="zoom: 67%;" />  

##### 2. 光线求交

<img src="L14.ray tracing(accelerate).assets/image-20221207100801600.png" alt="image-20221207100801600" style="zoom:67%;" /> 

- 如果光线和结点**不相交** 
  - 直接**舍弃**对应节点及其子节点
- 如果**相交** 
  - 和**内部节点**相交则继续考虑其**子节点** 
  - 和**叶子节点**相交则与该节点内**物体**光线求交

<img src="L14.ray tracing(accelerate).assets/image-20221207101725307.png" alt="image-20221207101725307" style="zoom:67%;" /> 

- 对于父节点实矩形，沿x轴划分出两个子节点左矩形右矩形，判断是否遍历其子节点
- $t_{min}$ 代表**进入矩形**时间
- $t_{max}$ 代表**离开矩形**时间
- $t_{split}$ 代表**经过划分轴**时间

##### 3. 如何创建一个好的 KD-Tree

<img src="L14.ray tracing(accelerate).assets/image-20221207103811837.png" alt="image-20221207103811837" style="zoom:67%;" /> 

<img src="L14.ray tracing(accelerate).assets/image-20221207103827211.png" alt="image-20221207103827211" style="zoom:80%;" />  

##### 4. 缺点

- 一个物体可能存在多个叶子节点中
- 很难判定AABB和空间中哪些三角形有交集
  - 如果认为三角形有顶点在AABB中就是有交集，但是可能存在AABB在三角形内部

#### 3. 例子——knn

<img src="L14.ray tracing(accelerate).assets/image-20221207103431270.png" alt="image-20221207103431270" style="zoom:67%;" /> 

| ![image-20221207103451770](L14.ray tracing(accelerate).assets/image-20221207103451770.png) | ![image-20221207103458025](L14.ray tracing(accelerate).assets/image-20221207103458025.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20221207103503594](L14.ray tracing(accelerate).assets/image-20221207103503594.png) | ![image-20221207103510817](L14.ray tracing(accelerate).assets/image-20221207103510817.png) |

### 3. Bounding Volume Hierarchy（BVH）

#### 1. 思想

不再以空间作为划分依据，而是从**物体**的角度考虑，即三角形面

#### 2. 划分

<img src="L14.ray tracing(accelerate).assets/image-20221207104041835.png" alt="image-20221207104041835" style="zoom:67%;" /> 

- 每次把**物体**划分为**两堆**，并**重新计算**包围盒

**如何划分** 

- 选择**最长**的轴划分
- 选择三角面重心坐标在划分轴上的**中位数**进行划分，保证两边三角形数量尽可能差不多
  - [快速选择算法（top K）](https://zhuanlan.zhihu.com/p/64627590) 

#### 3. 求交

<img src="L14.ray tracing(accelerate).assets/image-20221207104637248.png" alt="image-20221207104637248" style="zoom:80%;" />  

  